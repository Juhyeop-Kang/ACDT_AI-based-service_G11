// ===== ì„¤ì • =====
const API_KEY = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
const HISTORY_SPREADSHEET_ID = '1V2tRsESLriaHOKFT3ePO-GsE90S38n9pxhzPyjfcyBc';
const HISTORY_SHEET_NAME = 'ì¶œë ¥ê²°ê³¼';
const USER_SPREADSHEET_ID = '1GvCTUjfWHbjicnHWzNPnT047tjteiQuxn71iUtu5icU'; 
const USER_SHEET_NAME = 'ì‹œíŠ¸1';
const ADMIN_IDS = ['manager'];

// ===== ì›¹ ì•± ì§„ì…ì  =====
function doGet() {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('PickEase')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

// ===== ê¶Œí•œ ê°•ì œ ìŠ¹ì¸ìš© í•¨ìˆ˜ (ì‹¤í–‰ í›„ ì‚­ì œ ê°€ëŠ¥) =====
function forceAuth() {
  console.log("ê¶Œí•œ í™•ì¸ ë° ê°±ì‹  ì¤‘...");
  
  // 1. DriveApp ê¶Œí•œ í™•ì¸ (drive ìŠ¤ì½”í”„)
  const root = DriveApp.getRootFolder();
  console.log("Drive Access OK: " + root.getName());

  // 2. GmailApp ê¶Œí•œ í™•ì¸ (gmail.send ìŠ¤ì½”í”„)
  // ì£¼ì˜: ì´ ì½”ë“œëŠ” ì‹¤í–‰ ì‹œ ë³¸ì¸ì—ê²Œ í…ŒìŠ¤íŠ¸ ë©”ì¼ì„ 1í†µ ë°œì†¡í•©ë‹ˆë‹¤.
  const email = Session.getActiveUser().getEmail();
  if (email) {
    GmailApp.sendEmail(email, "[PickEase] ê¶Œí•œ ì„¤ì • í…ŒìŠ¤íŠ¸", "ì´ ë©”ì¼ì€ ê¶Œí•œ ìŠ¹ì¸ì„ í™•ì¸í•˜ê¸° ìœ„í•´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.");
    console.log("Gmail Access OK: í…ŒìŠ¤íŠ¸ ë©”ì¼ ë°œì†¡ ì„±ê³µ (" + email + ")");
  } else {
    console.log("ì´ë©”ì¼ ì£¼ì†Œë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ë©”ì¼ ë°œì†¡ì„ ê±´ë„ˆëœë‹ˆë‹¤.");
  }
  
  console.log("ëª¨ë“  ê¶Œí•œì´ ì •ìƒì ìœ¼ë¡œ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.");
}

// ===== í—¬í¼ í•¨ìˆ˜ =====
function getHistorySheet() {
  return SpreadsheetApp.openById(HISTORY_SPREADSHEET_ID).getSheetByName(HISTORY_SHEET_NAME);
}

function getUserSheet() {
  const ss = SpreadsheetApp.openById(USER_SPREADSHEET_ID);
  let sheet = ss.getSheetByName(USER_SHEET_NAME);
  if (!sheet) sheet = ss.getSheets()[0];
  return sheet;
}

function isAdminUser(userId) {
  if (!userId) return false;
  return ADMIN_IDS.indexOf(userId) !== -1;
}

function hashPassword(password) {
  const rawHash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);
  let txtHash = '';
  for (let i = 0; i < rawHash.length; i++) {
    let hashVal = rawHash[i];
    if (hashVal < 0) hashVal += 256;
    if (hashVal.toString(16).length == 1) txtHash += '0';
    txtHash += hashVal.toString(16);
  }
  return txtHash;
}

// ===== ì¸ì¦ ë° ì‚¬ìš©ì ê´€ë¦¬ =====
function checkIdExists(userId) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) return true;
  }
  return false;
}

function registerUser(userId, password, nickname, email) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) throw new Error('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì•„ì´ë””ì…ë‹ˆë‹¤.');
  }
  const passwordHash = hashPassword(password);
  const now = new Date();
  sheet.appendRow([userId, passwordHash, nickname, now, '', '{}', email]);
  
  // íšŒì›ê°€ì… ì¶•í•˜ ì´ë©”ì¼ ì „ì†¡
  const subject = '[PickEase] íšŒì›ê°€ì…ì„ í™˜ì˜í•©ë‹ˆë‹¤!';
  const body = `
ì•ˆë…•í•˜ì„¸ìš”, ${nickname}ë‹˜.

PickEaseì— ê°€ì…í•´ì£¼ì…”ì„œ ì§„ì‹¬ìœ¼ë¡œ ê°ì‚¬í•©ë‹ˆë‹¤!

ì´ì œ PickEaseì˜ ë‹¤ì–‘í•œ ìŒì‹ ì¶”ì²œ ê¸°ëŠ¥ì„ ì´ìš©í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê¸°ë¶„ê³¼ ìƒí™©ì— ë§ëŠ” ë§ì¶¤ ìŒì‹ ì¶”ì²œ
- ê³¼ê±° ê¸°ë¡ ê¸°ë°˜ ê°œì¸í™”ëœ ì¶”ì²œ
- ê·¼ì²˜ ë§›ì§‘ ì°¾ê¸°
- AI ì±—ë´‡ ìƒë‹´

ì–¸ì œë“ ì§€ ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ì‹œë©´ ë¬¸ì˜í•´ì£¼ì„¸ìš”.

ì¦ê±°ìš´ ì‹ì‚¬ ë˜ì„¸ìš”! ğŸ½ï¸

ê°ì‚¬í•©ë‹ˆë‹¤.
PickEase íŒ€
  `.trim();
  
  try {
    GmailApp.sendEmail(email, subject, body);
  } catch (e) {
    // ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨í•´ë„ íšŒì›ê°€ì…ì€ ì„±ê³µ ì²˜ë¦¬
    console.error('íšŒì›ê°€ì… ì¶•í•˜ ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨: ' + e.message);
  }
  
  return { success: true };
}

function loginUser(userId, password) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  const passwordHash = hashPassword(password);
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) {
      if (data[i][1] == passwordHash) {
        sheet.getRange(i + 1, 5).setValue(new Date());
        return { success: true, userId: userId, nickname: data[i][2], preferences: data[i][5] || '{}' };
      } else {
        console.log(`Login Failed for ${userId}: Stored[${data[i][1]}] vs Input[${passwordHash}]`);
        throw new Error('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      }
    }
  }
  throw new Error('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì•„ì´ë””ì…ë‹ˆë‹¤.');
}

function getUserInfo(userId) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) {
      return { nickname: data[i][2], preferences: data[i][5] || '{}' };
    }
  }
  throw new Error('ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
}

function updateUserInfo(userId, nickname, preferencesJson) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) {
      if (nickname) sheet.getRange(i + 1, 3).setValue(nickname);
      if (preferencesJson) sheet.getRange(i + 1, 6).setValue(preferencesJson);
      return { success: true };
    }
  }
  throw new Error('ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
}

function changePassword(userId, currentPassword, newPassword) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  const currentHash = hashPassword(currentPassword);
  const newHash = hashPassword(newPassword);
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) {
      if (data[i][1] == currentHash) {
        sheet.getRange(i + 1, 2).setValue(newHash);
        return { success: true };
      } else {
        throw new Error('í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      }
    }
  }
  throw new Error('ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì˜¤ë¥˜');
}

function deleteAccount(userId) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId) {
      sheet.deleteRow(i + 1);
      return { success: true };
    }
  }
  return { success: false };
}

function resetPassword(userId, email) {
  const sheet = getUserSheet();
  const data = sheet.getDataRange().getValues();
  
  // ì‚¬ìš©ì IDì™€ ì´ë©”ì¼ ìŒì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == userId && data[i][6] == email) {
      // ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ìƒì„± (ì˜ë¬¸, ìˆ«ì í¬í•¨ 10ìë¦¬ - íŠ¹ìˆ˜ë¬¸ì ì œì™¸)
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let tempPassword = '';
      for (let j = 0; j < 10; j++) {
        tempPassword += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      
      // ë¹„ë°€ë²ˆí˜¸ í•´ì‹œí™”
      const tempPasswordHash = hashPassword(tempPassword);
      
      // ë°ì´í„°ë² ì´ìŠ¤ì— ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì €ì¥
      sheet.getRange(i + 1, 2).setValue(tempPasswordHash);
      
      // ì´ë©”ì¼ ì „ì†¡
      const subject = '[PickEase] ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ ì•ˆë‚´';
      const body = `
ì•ˆë…•í•˜ì„¸ìš”, ${data[i][2]}ë‹˜.

PickEase ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° ìš”ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.

ì„ì‹œ ë¹„ë°€ë²ˆí˜¸: ${tempPassword}

ë³´ì•ˆì„ ìœ„í•´ ë¡œê·¸ì¸ í›„ ì¦‰ì‹œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•´ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.

ê°ì‚¬í•©ë‹ˆë‹¤.
PickEase íŒ€
      `.trim();
      
      try {
        // GmailApp ì‚¬ìš© (Gmail API ì„œë¹„ìŠ¤ê°€ ì¶”ê°€ë˜ì–´ ìˆì–´ì•¼ í•¨)
        GmailApp.sendEmail(email, subject, body);
        return { success: true, message: 'ì„ì‹œ ë¹„ë°€ë²ˆí˜¸ê°€ ì´ë©”ì¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.' };
      } catch (e) {
        // ìƒì„¸ ì—ëŸ¬ ë¡œê¹…
        console.error('resetPassword Error: ' + e.toString());
        // ì‚¬ìš©ìì—ê²ŒëŠ” êµ¬ì²´ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ ì „ë‹¬ (ë””ë²„ê¹…ìš©)
        throw new Error('ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨: ' + e.message);
      }
    }
  }
  
  throw new Error('ì•„ì´ë””ì™€ ì´ë©”ì¼ì´ ì¼ì¹˜í•˜ëŠ” ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
}

// ===== í†µê³„ ê³„ì‚° ë¡œì§ =====
function updateSessionStats(userId, timestampStr) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  const targetIndices = [];
  let L = 0, D = 0, S = 0, N = 0;
  const targetDate = new Date(timestampStr);
  
  for (let i = 1; i < data.length; i++) {
    const rowDate = new Date(data[i][0]);
    if (data[i][1] === userId && Math.abs(rowDate.getTime() - targetDate.getTime()) < 10000) {
      targetIndices.push(i + 1);
      N++;
      const feedback = data[i][6];
      const isSaved = data[i][7];
      if (feedback === 'ì¢‹ì•„ìš”') L++;
      if (feedback === 'ì‹«ì–´ìš”') D++;
      if (isSaved === true || isSaved === 'TRUE') S++;
    }
  }
  
  if (N === 0) return;
  const F = L + S + D;
  const denominator = L + (1.5 * S) + D;
  const rawScore = denominator === 0 ? 0 : (L + (1.5 * S) - D) / denominator;
  const normalizedScore = (rawScore + 1) / 2;
  const participationRate = F / N;
  
  if (sheet.getLastColumn() < 10) sheet.getRange(1, 10).setValue('í”¼ë“œë°± ì°¸ì—¬ìœ¨');

  targetIndices.forEach(rowIndex => {
    sheet.getRange(rowIndex, 9).setValue(normalizedScore);
    sheet.getRange(rowIndex, 10).setValue(participationRate);
  });
}

// ===== ì¶”ì²œ ë° ì´ë ¥ ê¸°ëŠ¥ =====
function getUserHistory(userId) {
  const sheet = getHistorySheet();
  if (sheet.getLastRow() <= 1) return { liked: {}, disliked: {}, saved: [] };
  const data = sheet.getDataRange().getValues();
  const likedFoods = {};
  const dislikedFoods = {};
  const savedFoods = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === userId) {
      const foodName = data[i][4];
      const feedback = data[i][6];
      const isSaved = data[i][7];
      if (feedback === 'ì¢‹ì•„ìš”') likedFoods[foodName] = (likedFoods[foodName] || 0) + 1;
      if (feedback === 'ì‹«ì–´ìš”') dislikedFoods[foodName] = (dislikedFoods[foodName] || 0) + 1;
      if ((isSaved === 'TRUE' || isSaved === true) && !savedFoods.includes(foodName)) savedFoods.push(foodName);
    }
  }
  return { liked: likedFoods, disliked: dislikedFoods, saved: savedFoods };
}

function getSimpleRecommendations(userId, selectedKeywords, customMood, excludeFoods = [], lang = 'ko', additionalRequest = '') {
  const history = getUserHistory(userId);
  const userInfo = getUserInfo(userId);
  const prefs = JSON.parse(userInfo.preferences || '{}');
  const prefTags = prefs.tags ? prefs.tags.join(', ') : '';
  const likedEntries = Object.entries(history.liked || {}).map(([food, count]) => `${food}(${count})`);
  const dislikedEntries = Object.entries(history.disliked || {}).map(([food, count]) => `${food}(${count})`);
  const dislikedList = Object.keys(history.disliked || {});

  let userInput = selectedKeywords ? selectedKeywords.join(', ') : '';
  if (customMood) userInput += (userInput ? ', ' : '') + customMood;
  if (additionalRequest && additionalRequest.trim()) {
    userInput += (userInput ? ', ' : '') + additionalRequest.trim();
  }

  const absoluteExclude = [...new Set([...(excludeFoods || []), ...dislikedList])];
  const likedSummary = likedEntries.length ? likedEntries.join(', ') : 'ì—†ìŒ';
  const dislikedSummary = dislikedEntries.length ? dislikedEntries.join(', ') : 'ì—†ìŒ';

  const langInstruction = lang === 'en' ? "Respond only in English." : "í•œêµ­ì–´ë¡œë§Œ ë‹µë³€í•´ì¤˜.";

  const prompt = buildPickEasePrompt({
    userInput,
    prefTags,
    likedSummary,
    dislikedSummary,
    absoluteDislikes: dislikedList,
    excludeList: absoluteExclude,
    langInstruction
  });

  const payload = { contents: [{ parts: [{ text: prompt }] }] };
  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'x-goog-api-key': API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent', options);
    const data = JSON.parse(response.getContentText());
    const content = data.candidates[0].content.parts[0].text;
    const foods = parseGeminiResponse(content);
    
    const sheet = getHistorySheet();
    const allKeywords = (selectedKeywords || []).slice();
    if (customMood) allKeywords.push(customMood);
    if (additionalRequest && additionalRequest.trim()) {
      allKeywords.push(additionalRequest.trim());
    }
    const now = new Date();
    
    foods.forEach((food, index) => {
      sheet.appendRow([now, userId, 'ê°„í¸ì„ íƒ', allKeywords.join(', '), food.name, index + 1, 'ì—†ìŒ', 'FALSE', 0.5, 0]); 
    });
    return { foods: foods };
  } catch (e) {
    throw new Error('Recommendation Error: ' + e.message);
  }
}

function getRandomRecommendations(userId, excludeFoods = [], lang = 'ko') {
  const now = new Date();
  const langInstruction = lang === 'en' ? "Respond only in English." : "í•œêµ­ì–´ë¡œë§Œ ë‹µë³€í•´ì¤˜.";
  const prompt = (() => {
    const history = getUserHistory(userId);
    const userInfo = getUserInfo(userId);
    const prefs = JSON.parse(userInfo.preferences || '{}');
    const prefTags = prefs.tags ? prefs.tags.join(', ') : 'None';
    const likes = Object.entries(history.liked || {}).map(([f, c]) => `${f}(${c})`).join(', ') || 'None';
    const saved = (history.saved || []).join(', ') || 'None';
    const dislikes = Object.entries(history.disliked || {}).map(([f, c]) => `${f}(${c})`).join(', ') || 'None';
    const excluded = [...new Set([...(excludeFoods || []), ...Object.keys(history.disliked || {})])];
    return `
User Context:
- Taste Tags: ${prefTags}
- Likes: ${likes}
- Saved: ${saved}
- Dislikes: ${dislikes}
- Exclude (must not appear): ${excluded.length ? excluded.join(', ') : 'None'}

Task: Recommend 10 foods that feel random yet aligned with taste.
- Include 3-5 items inspired by likes/saves or taste tags (fresh twists/variations welcome).
- Fill the rest with diverse, novel options that still match the overall taste.
- STRICT: Never include excluded or disliked items.
- Prefer variety across cuisine, cooking style, and temperature; avoid exact repeats.
- 10ê°œ ëª¨ë‘ ë‹¤ë¥¸ ìŒì‹ì´ì–´ì•¼ í•œë‹¤. ì¤‘ë³µ ê¸ˆì§€.
- Keep the tone natural. Format as "1. Food - Reason".
- í˜•ì‹ì€ ë°˜ë“œì‹œ '1. ìŒì‹ - ì´ìœ 'ë¡œ, ìˆ«ìëŠ” 1~10ê¹Œì§€ ì •í™•íˆ ì‚¬ìš©í•œë‹¤.
${langInstruction}
`;
  })();
  const payload = { contents: [{ parts: [{ text: prompt }] }] };
  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'x-goog-api-key': API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  
  try {
    const response = UrlFetchApp.fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent', options);
    const data = JSON.parse(response.getContentText());
    const content = data.candidates[0].content.parts[0].text;
    const foods = parseGeminiResponse(content);
    
    const sheet = getHistorySheet();
    foods.forEach((food, index) => {
      sheet.appendRow([now, userId, 'ëœë¤', '', food.name, index + 1, 'ì—†ìŒ', 'FALSE', 0.5, 0]);
    });
    return { foods: foods };
  } catch(e) {
    throw new Error('Error');
  }
}

function parseGeminiResponse(response) {
  const lines = response.split('\n').filter(line => line.trim());
  const foods = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const match = line.match(/^\d+[\.\)]\s*\*?\*?(.+?)\*?\*?\s*[-â€“â€”:]\s*(.+)$/);
    if (match) {
      foods.push({ name: match[1].trim().replace(/\*\*/g, ''), reason: match[2].trim() });
    }
    if (foods.length >= 10) break;
  }
  return foods.length > 0 ? foods : [{ name: 'Pizza', reason: 'Failed to parse' }];
}

function buildPickEasePrompt({ userInput, prefTags, likedSummary, dislikedSummary, absoluteDislikes, excludeList, langInstruction }) {
  const currentInputText = userInput && userInput.trim() ? userInput.trim() : 'ì‚¬ìš©ì í˜„ì¬ ì…ë ¥ ì—†ìŒ';
  const prefTagText = prefTags && prefTags.trim() ? prefTags : 'ì„ íƒëœ íƒœê·¸ ì—†ìŒ';
  const likesText = likedSummary && likedSummary.trim() ? likedSummary : 'ê¸°ë¡ ì—†ìŒ';
  const dislikesText = dislikedSummary && dislikedSummary.trim() ? dislikedSummary : 'ê¸°ë¡ ì—†ìŒ';
  const mustNotList = absoluteDislikes && absoluteDislikes.length ? absoluteDislikes.join(', ') : 'ì—†ìŒ';
  const excludeText = excludeList && excludeList.length ? excludeList.join(', ') : 'ì—†ìŒ';

  return `
# 1. ìµœìš°ì„ : í˜„ì¬ ì…ë ¥ (ê°€ì¥ ì¤‘ìš”)
- ${currentInputText}

# 2. ë³´ì¡°ì  ì°¸ê³ ìë£Œ: ì„ í˜¸ íƒœê·¸ / ê³¼ê±° ì¢‹ì•„ìš”Â·ì‹«ì–´ìš”
- ì„ í˜¸ íƒœê·¸: ${prefTagText}
- ê³¼ê±° ì¢‹ì•„ìš” ëª©ë¡: ${likesText}
- ê³¼ê±° ì‹«ì–´ìš” ëª©ë¡: ${dislikesText}

# 3. ì ˆëŒ€ ê¸ˆì§€: ì‹«ì–´ìš” ìŒì‹ ë° ì œì™¸ ìš”ì²­
- ì‹«ì–´ìš” ìŒì‹: ${mustNotList}
- ì¶”ê°€ ì œì™¸ ìš”ì²­: ${excludeText}

Task: Recommend exactly 10 food items based on the above.
- ìµœìš°ì„ ìœ¼ë¡œ í˜„ì¬ ì…ë ¥ì„ ë°˜ì˜í•˜ê³ , ì„ í˜¸/íˆìŠ¤í† ë¦¬ëŠ” ì°¸ê³ ë§Œ í•œë‹¤.
- HistoryëŠ” ìµœëŒ€ 1~2ê°œ í•­ëª©ë§Œ í™œìš©í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” í˜„ì¬ ì…ë ¥ ì¤‘ì‹¬ìœ¼ë¡œ ë‹¤ì–‘í•˜ê²Œ ì œì•ˆí•œë‹¤.
- Never recommend disliked or excluded foods.
- 10ê°œ ëª¨ë‘ ë‹¤ë¥¸ ìŒì‹ì´ì–´ì•¼ í•œë‹¤. ì¤‘ë³µ ê¸ˆì§€.
- í˜•ì‹ì€ ë°˜ë“œì‹œ '1. ìŒì‹ - ì´ìœ 'ë¡œ, ìˆ«ìëŠ” 1~10ê¹Œì§€ ì •í™•íˆ ì‚¬ìš©í•œë‹¤.
- Don't copy the exact wording from the user input. Reasons must be natural sentences without quotes.
- If there is no current input, lean more on likes/saves to infer general taste.
- Lineup according to ranking from 1 to 10 with no missing numbers.

${langInstruction}
  `.trim();
}

// ===== ë‚˜ë¨¸ì§€ ê¸°ì¡´ í•¨ìˆ˜ë“¤ (saveFeedback, saveFood, deleteFood, getSavedFoods, getLikedFoods, getDislikedFoods, getHistoryDates, getHistoryByDate, getPerformanceTrendData, findNearbyRestaurants, chatWithAI, getMoodCoachMessage ë“±) =====
// ...keep your remaining 3.9.1 implementations below, unchanged...

function parseGeminiResponse(response) {
  const lines = response.split('\n').filter(line => line.trim());
  const foods = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const match = line.match(/^\d+[\.\)]\s*\*?\*?(.+?)\*?\*?\s*[-â€“â€”:]\s*(.+)$/);
    if (match) {
      foods.push({ name: match[1].trim().replace(/\*\*/g, ''), reason: match[2].trim() });
    }
    if (foods.length >= 10) break;
  }
  return foods.length > 0 ? foods : [{ name: 'Pizza', reason: 'Failed to parse' }];
}

function saveFeedback(userId, foodName, feedback) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  let targetTimestamp = null;
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][1] === userId && data[i][4] === foodName) {
      sheet.getRange(i + 1, 7).setValue(feedback);
      targetTimestamp = data[i][0];
      break;
    }
  }
  if (targetTimestamp) {
    updateSessionStats(userId, targetTimestamp);
    return { success: true };
  }
  return { success: false };
}

function saveFood(userId, foodName) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  let targetTimestamp = null;
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][1] === userId && data[i][4] === foodName) {
      sheet.getRange(i + 1, 8).setValue('TRUE');
      targetTimestamp = data[i][0];
      break;
    }
  }
  if (targetTimestamp) {
    updateSessionStats(userId, targetTimestamp);
    return { success: true };
  }
  return { success: false };
}

function deleteFood(userId, foodName, type) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  let targetTimestamp = null;
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][1] === userId && data[i][4] === foodName) {
      if (type === 'saved') sheet.getRange(i + 1, 8).setValue('FALSE');
      else if (type === 'liked' || type === 'disliked') sheet.getRange(i + 1, 7).setValue('ì—†ìŒ');
      targetTimestamp = data[i][0];
      break; 
    }
  }
  if (targetTimestamp) {
    updateSessionStats(userId, targetTimestamp);
    return { success: true };
  }
  return { success: true };
}

function getSavedFoods(userId) { return getFoodsByType(userId, 'saved'); }
function getLikedFoods(userId) { return getFoodsByType(userId, 'liked'); }
function getDislikedFoods(userId) { return getFoodsByType(userId, 'disliked'); }

function getFoodsByType(userId, type) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  const foods = new Set();
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === userId) {
      const foodName = data[i][4], feedback = data[i][6], isSaved = data[i][7];
      if (type === 'saved' && (isSaved === true || isSaved === 'TRUE')) foods.add(foodName);
      else if (type === 'liked' && feedback === 'ì¢‹ì•„ìš”') foods.add(foodName);
      else if (type === 'disliked' && feedback === 'ì‹«ì–´ìš”') foods.add(foodName);
    }
  }
  return Array.from(foods);
}

function getHistoryDates(userId) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  const dates = new Set();
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === userId) {
      const dateObj = new Date(data[i][0]);
      if (!isNaN(dateObj)) {
        const y = dateObj.getFullYear();
        const m = String(dateObj.getMonth() + 1).padStart(2, '0');
        const d = String(dateObj.getDate()).padStart(2, '0');
        dates.add(`${y}-${m}-${d}`);
      }
    }
  }
  return Array.from(dates);
}

function getHistoryByDate(userId, dateStr) {
  const sheet = getHistorySheet();
  const data = sheet.getDataRange().getValues();
  const items = [];
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === userId) {
      const dateObj = new Date(data[i][0]);
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2, '0');
      const d = String(dateObj.getDate()).padStart(2, '0');
      const currentStr = `${y}-${m}-${d}`;
      
      if (currentStr === dateStr) {
        const feedback = data[i][6];
        const isSaved = data[i][7];
        const inputVal = data[i][3] ? data[i][3] : (data[i][2] === 'ê°„í¸ì„ íƒ' ? 'ê°„í¸í•œ ì„ íƒ' : '');
        items.push({
          name: data[i][4],
          rank: data[i][5],
          isLiked: feedback === 'ì¢‹ì•„ìš”',
          isDisliked: feedback === 'ì‹«ì–´ìš”',
          isSaved: isSaved === true || isSaved === 'TRUE',
          input: inputVal
        });
      }
    }
  }
  return items;
}

function getPerformanceTrendData(adminUserId, targetUserId) {
  if (!isAdminUser(adminUserId)) throw new Error('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.');
  const sheet = getHistorySheet();
  if (sheet.getLastRow() <= 1) return { trend: [], users: [] };
  const data = sheet.getDataRange().getValues();
  const sessionMap = {};
  const normalizedTarget = targetUserId && targetUserId !== 'ALL' ? targetUserId : null;

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const userId = row[1];
    const timestamp = row[0];
    const metricValue = row[8];
    if (!userId || (normalizedTarget && userId !== normalizedTarget)) continue;
    if (metricValue === '' || metricValue === null || metricValue === undefined) continue;
    const timeValue = new Date(timestamp).getTime();
    if (isNaN(timeValue)) continue;
    const key = `${userId}|${timeValue}`;
    if (!sessionMap[key]) {
      const numericMetric = Number(metricValue);
      if (isNaN(numericMetric)) continue;
      sessionMap[key] = { userId, time: timeValue, metric: numericMetric };
    }
  }

  const userSessions = {};
  Object.values(sessionMap).forEach(session => {
    if (!userSessions[session.userId]) userSessions[session.userId] = [];
    userSessions[session.userId].push(session);
  });

  const userList = Object.keys(userSessions).map(uid => ({
    userId: uid,
    attempts: userSessions[uid].length
  })).sort((a, b) => a.userId.localeCompare(b.userId));

  const sessionArrays = normalizedTarget
    ? (userSessions[normalizedTarget] ? [userSessions[normalizedTarget]] : [])
    : Object.values(userSessions);
  if (sessionArrays.length === 0) return { trend: [], users: userList };
  sessionArrays.forEach(list => list.sort((a, b) => a.time - b.time));

  let maxAttempts = 0;
  sessionArrays.forEach(list => {
    if (list.length > maxAttempts) maxAttempts = list.length;
  });

  const trend = [];
  const cumulativeTrend = [];
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    let sum = 0;
    let count = 0;
    sessionArrays.forEach(list => {
      const entry = list[attempt - 1];
      if (entry && !isNaN(entry.metric)) {
        sum += entry.metric;
        count++;
      }
    });
    if (count > 0) {
      const avg = sum / count;
      trend.push({ attempt: attempt, average: avg, count: count });
      const prev = cumulativeTrend[cumulativeTrend.length - 1];
      const cumAvg = prev ? ((prev.average * prev.count) + (avg * count)) / (prev.count + count) : avg;
      cumulativeTrend.push({ attempt: attempt, average: cumAvg, count: (prev ? prev.count : 0) + count });
    }
  }

  return { trend: trend, cumulativeTrend: cumulativeTrend, users: userList };
}

// ===== ë§›ì§‘ ê²€ìƒ‰ (Google Maps Grounding) =====
function findNearbyRestaurants(foodName, locationData, lang = 'ko') {
  const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
  
  const langInstruction = lang === 'en' ? "Respond only in English." : "í•œêµ­ì–´ë¡œë§Œ ë‹µë³€í•´ì¤˜.";
  
  let prompt = `Find 3-5 highly rated ${foodName} restaurants `;
  if (locationData.lat && locationData.lng) {
    prompt += `near coordinates (${locationData.lat}, ${locationData.lng}). `;
  } else if (locationData.query) {
    prompt += `near ${locationData.query}. `;
  } else {
    prompt += "nearby. ";
  }
  
  prompt += `
    ${langInstruction}
    
    **CRITICAL REQUIREMENTS:**
    - You MUST use ONLY real restaurant data from Google Maps Grounding. Do NOT invent or create fictional restaurants.Doublecheck if there exist now.
    - Only return restaurants that actually exist in Google Maps.
    - If you cannot find enough real restaurants, return fewer results rather than making up fake ones.
    - All restaurant names, ratings, and summaries must be based on actual Google Maps data.
    - Nearby means not far than 2km.
    
    Return the result ONLY in the following JSON format:
    [
      {
        "name": "Restaurant Name",
        "rating": 4.5,
        "summary": "Brief summary of why it is good."
      },
      ...
    ]
    Do not include markdown formatting (like \`\`\`json). Just raw JSON array.
  `;

  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    tools: [{ googleMaps: {} }]
  };

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'x-goog-api-key': API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const data = JSON.parse(response.getContentText());
    
    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
       const text = data.candidates[0].content.parts.map(p => p.text).join('');
       const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
       return { text: cleanedText };
    } else {
      return { text: "[]" }; 
    }
  } catch (e) {
    return { text: JSON.stringify([{ name: "Error", rating: 0, summary: e.message }]) };
  }
}

// ===== AI ì±—ë´‡ (Gemini 3 Pro) =====
function chatWithAI(message) {
  const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent'; // gemini-3-pro-preview ì‚¬ìš©
  
  const payload = {
    contents: [{ parts: [{ text: message }] }]
  };

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'x-goog-api-key': API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const data = JSON.parse(response.getContentText());
    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
      return { text: data.candidates[0].content.parts[0].text };
    }
    return { text: "ì£„ì†¡í•´ìš”, ë‹µë³€ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤." };
  } catch (e) {
    return { text: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message };
  }
}

// ===== AI Mood Coach =====
function getMoodCoachMessage(selectedKeywords, customMood, lang = 'ko') {
  const langInstruction = lang === 'en' ? "Respond only in English." : "í•œêµ­ì–´ë¡œë§Œ ë‹µë³€í•´ì¤˜.";
  
  let userInput = selectedKeywords ? selectedKeywords.join(', ') : '';
  if (customMood) userInput += (userInput ? ', ' : '') + customMood;
  
  if (!userInput.trim()) {
    return { text: lang === 'ko' ? 'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë³´ë‚´ì„¸ìš”! ğŸ˜Š' : 'Have a great day! ğŸ˜Š' };
  }
  
  const prompt = `
    User's current mood/input: ${userInput}
    
    Task: As a warm and empathetic mood coach, provide a brief, encouraging message (1-2 sentences) based on the user's input.
    - Be supportive and understanding
    - Keep it short and genuine
    - Don't mention food recommendations
    - Focus on emotional support
    
    ${langInstruction}
  `;

  const payload = { contents: [{ parts: [{ text: prompt }] }] };
  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'x-goog-api-key': API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent', options);
    const data = JSON.parse(response.getContentText());
    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
      return { text: data.candidates[0].content.parts[0].text.trim() };
    }
    return { text: lang === 'ko' ? 'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë³´ë‚´ì„¸ìš”! ğŸ˜Š' : 'Have a great day! ğŸ˜Š' };
  } catch (e) {
    return { text: lang === 'ko' ? 'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë³´ë‚´ì„¸ìš”! ğŸ˜Š' : 'Have a great day! ğŸ˜Š' };
  }
}
